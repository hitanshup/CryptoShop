"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
class FileSystem {
    listFileNames(path) {
        return fs_1.readdirSync(path) || [];
    }
    listValidDirectories(inputDirectory) {
        const filesAndDirectories = this.listFileNames(inputDirectory);
        const directories = filesAndDirectories.filter(fileOrDirectory => {
            const path = `${inputDirectory}/${fileOrDirectory}`;
            return (this.isDirectory(path) &&
                !this.isEmpty(path) &&
                !this.isHidden(fileOrDirectory));
        });
        return directories;
    }
    isEmpty(path) {
        return this.listFileNames(path).length === 0;
    }
    isHidden(fileOrDirectoryName) {
        return fileOrDirectoryName.startsWith('.');
    }
    isDirectory(path) {
        const stats = fs_1.lstatSync(path);
        return stats.isDirectory();
    }
    filterSupportedDocumentFileNames(fileNames, supportedExtensions) {
        const documentFileNames = fileNames.filter(fileName => {
            const fileNameSplit = fileName.split(FileSystem.FILE_NAME_SPLIT_CHARACTER);
            if (this.shouldIgnoreFile(fileNameSplit)) {
                return false;
            }
            const fileExtension = fileNameSplit.pop();
            return supportedExtensions.some(extension => extension.toLowerCase() === fileExtension.toLowerCase());
        });
        return documentFileNames;
    }
    shouldIgnoreFile(fileNameSplitByDot) {
        const isHidden = !fileNameSplitByDot[0];
        const hasNoExtension = fileNameSplitByDot.length === 1;
        return isHidden || hasNoExtension;
    }
    readFilesContent(filePaths) {
        return filePaths.reduce((arr, filePath) => {
            const fileContent = require(filePath);
            return arr.concat(fileContent);
        }, []);
    }
}
FileSystem.FILE_NAME_SPLIT_CHARACTER = '.';
exports.FileSystem = FileSystem;
exports.fileSystem = new FileSystem();
//# sourceMappingURL=filesystem.js.map